options {
JAVA_UNICODE_ESCAPE = true;
UNICODE_INPUT = true;
OUTPUT_LANGUAGE = "c++";
NAMESPACE = "alinouslang";
OUTPUT_DIRECTORY = "src_gen/alinous_lang/";
FORCE_LA_CHECK = false;
ERROR_REPORTING = true;
PARSER_INCLUDES = "sc/alinouslang.h";
//STATIC = false; // ignored by c++
}

PARSER_BEGIN(AlinousLang)

// write includes here

PARSER_END(AlinousLang)

/******************************************************************************************
* Alinous Language Lex
*/

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

<*>TOKEN :
{
	<#NOTASCII: ["\u0080"-"\ufaff"]>	|
	<#ASCILETTER: ["a"-"z"] | ["A"-"Z"] | ["_"]> |
	<#NUMBERLETTER: ["0"-"9"]> |

	
	<#CHARACTOR: <NOTASCII> | <ASCILETTER> | <NUMBERLETTER> >
}

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        <DECIMAL_FLOATING_POINT_LITERAL>
      | <HEXADECIMAL_FLOATING_POINT_LITERAL>
  >
|
  < #DECIMAL_FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]
  >
|
  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < #HEXADECIMAL_FLOATING_POINT_LITERAL:
        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
  >
|
  < #HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+ >

|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | "u" (["0"-"9","a"-"f","A"-"F"])+
            )
          )
      )
      "'"
  >
|
  < SQL_STRING_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | "u" (["0"-"9","a"-"f","A"-"F"])+
            )
          )
      )*
      "'"
  >
}

TOKEN :
{
	<SEMI_COLON: ";">		|
	<EQUALS: "=">			|
	<ASTERISK: "*">			|
	<PLUSPLUS: "++">		|
	<PLUS: "+">				|
	<MINUSMINUS: "--">		|
	<MINUS: "-">			|
	<DIV: "/">				|
	<MODULO: "%">			|
	<LOGICAL_AND: "&&">		|
	<LOGICAL_OR: "||">		|
	<BIT_AND: "&">			|
	<BIT_OR: "|">			|
	<L_PARENTHESIS: "(">	|
	<R_PARENTHESIS: ")">	|
	<L_BRACKET: "[">		|
	<R_BRACKET: "]">		|
	<DOLLAR: "$">			|
	<DOT: ".">				|
	<COMMA: ",">			|
	<AT_AT_MARK: "@@">		|
	<AT_MARK: "@">			|
	<L_BRACE: "{">			|
	<R_BRACE: "}">			|
	<CMP_EQUALS: "==">		|
	<CMP_NOTEQUALS: "!=">	|
	< GT: ">" >				|
	<GEQ: ">=">				|
	<LT: "<">				|
	<LEQ: "<=">				|
	<NOT: "!">				|
	<COLON: ":">			|

	<RSIGNEDSHIFT: ">>" >	|
	<RUNSIGNEDSHIFT: ">>>" >
}

TOKEN :
{
<IMPORT: "import">
| <PACKAGE: "package">
| <CLASS: "class">
| <CLASS_INTERFACE: "interface">
| < ABSTRACT: "abstract" >
| < BREAK: "break" >
| < CHAR: "char" >
| < SHORT: "short" >
| < INT: "int" >
| < LONG: "long" >
| < STRING: "String" >
| < CASE: "case" >
| < CATCH: "catch" >
| < _CONST: "const" >
| < CONTINUE: "continue" >
| < DO: "do" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FINALLY: "finally" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < INSTANCEOF: "instanceof" >
| < NEW: "new" >
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >

| < TRY: "try" >
| < VOID: "void" >
| < WHILE: "while" >
| <INCLUDE: "include" >
	
| < TRUE: "true" >
| < FALSE: "false" >
}


TOKEN [IGNORE_CASE] :
{
	<SELECT: "SELECT">	|
	<INSERT: "INSERT">	|
	<UPDATE: "UPDATE">	|
	<DELETE: "DELETE">	|
	<INTO: "INTO">		|
	<FROM: "FROM">		|
	<WHERE: "WHERE">	|
	<OR: "OR">			|
	<SQLAND: "AND">		|
	<LIKE: "LIKE">		|
	<ESCAPE: "<ESCAPE>">	|
	<LEFT: "LEFT">		|
	<RIGHT: "RIGHT">	|
	<NATURAL: "NATURAL">|
	<INNER: "INNER">	|
	<OUTER: "OUTER">	|
	<FULL: "FULL">		|
	<JOIN: "JOIN">		|
	<CROSS: "CROSS">	|
	<SET: "SET">		|
	<VALUES: "VALUES">	|
	<GROUP: "GROUP">	|
	<BY: "BY">			|
	<HAVING: "HAVING">	|
	<ORDER: "ORDER">	|
	<ASC: "ASC">		|
	<DESC: "DESC">		|
	
	<LIMIT: "LIMIT">	|
	<OFFSET: "OFFSET">	|
	<ON: "ON">			|
	<SQL_NOT: "NOT">	|
	<AS: "AS">			|
	<DISTINCT: "DISTINCT">		|
	
	<SHARE: "SHARE">	|
	<NOWAIT: "NOWAIT">	|
	<OF: "OF">			|
	
	<IN: "IN">			|
	<BETWEEN: "BETWEEN">	|
	<IS: "IS">			|
	
	<BEGIN: "BEGIN">	|
	<PREPARE: "PREPARE">	|
	<TRANSACTION: "TRANSACTION">	|
	<ISOLATION: "ISOLATION">	|
	<LEVEL: "LEVEL">	|
	
	<COMMIT: "COMMIT">	|
	<PREPARED: "PREPARED">	|
	<END: "END">		|
	<ROLLBACK: "ROLLBACK">		|

	<CREATE: "CREATE">		|
	<DROP: "DROP">		|
	<ALTER: "ALTER">	|
	<TABLE: "TABLE">	|
	<SQL_DEFAULT: "DEFAULT">	|
	<ADD: "ADD">	|
	<RENAME: "RENAME">	|
	<COLUMN: "COLUMN">	|
	<TO: "TO">	|
	<PRIMARY: "PRIMARY">	|
	<KEY: "KEY">	|
	<UNIQUE: "UNIQUE">	|
	<CHECK: "CHECK">	|
	<RETURNS: "RETURNS">	|
	<SETOF: "SETOF">	|
	<LANGUAGE: "LANGUAGE">	|
	<REPLACE: "REPLACE">	|
	<INDEX: "INDEX">	|
	<USING: "USING">	|
	
	<EACH: "EACH">		|
	<ROW: "ROW">		|
	<STATEMENT: "STATEMENT">|
	<EXECUTE: "EXECUTE">	|
	<PROCEDURE: "PROCEDURE">		|
	<EXISTS: "EXISTS">	|
	
	<TRIGGER: "TRIGGER">	|
	<BEFORE: "BEFORE">	|
	<AFTER: "AFTER">	|
	
	<FOREIGN: "FOREIGN">	|
	<REFERENCES: "REFERENCES">	|
	
	<ADJUST_WHERE: "ADJUST_WHERE">	|
	<ADJUST_SET: "ADJUST_SET">	|
	
	<BOOL: "BOOL">		|
	
	<_NULL: "NULL">		|
	
	<FUNCTION: "FUNCTION">	|

	<USE: "USE" >  |
	<REGION: "REGION"> |
	<PARTITION: "PARTITION" > |
	<SUB: "SUB">		|
	<SERIALIZABLE: "SERIALIZABLE">	|
	<READ: "READ">	|
	<COMMITTED: "COMMITTED">


}

TOKEN :
{
	<IDENTIFIER: <ASCILETTER> (<ASCILETTER> | <NUMBERLETTER>)*>
}

MORE:
{
	< "/*" > :COMM	 |
	< "//" > :L_COMM
}

<L_COMM>SPECIAL_TOKEN:
{
	< "\n" > : DEFAULT
}

<L_COMM>MORE:
{
	< ~[] >
}

<COMM>SPECIAL_TOKEN:
{
	< "*/" > : DEFAULT
}

<COMM>MORE:
{
	< ~[] >
}

/******************************************************************************************
* Alinous Language Starts
*/

CompilationUnit* compilationUnit() :
{
	CompilationUnit* unit = new CompilationUnit();
	PackageDeclare* pkg = nullptr;
	ClassDeclare* clazz = nullptr;
}
{
	[
		pkg=packageDeclare() {
			unit->setPackage(pkg);
		}
	]
    
	(
	    clazz=classDeclare() {
			unit->setPosition(clazz);
			unit->addClassDeclare(clazz);
	    }
	)+
	<EOF>
	{
		return unit;
	}
}

PackageDeclare* packageDeclare() : {
	PackageDeclare* pkg = nullptr;
	PackageNameDeclare* name = nullptr;
	Token* t = nullptr;
}
{
	t="package" {
		pkg=new PackageDeclare();
		pkg->setPosition(t);
	}

	name=packageNameDeclare() {
	    pkg->setName(name);
		pkg->setPosition(name);
	}
	
	";" {
		pkg->setPosition(t);
	}
	{
	    __ONERROR(pkg);
		return pkg;
	}
}

PackageNameDeclare* packageNameDeclare() :
{
	PackageNameDeclare* names = nullptr;
	Token* t = nullptr;
}
{
	t=< IDENTIFIER > {
	    names = new PackageNameDeclare();
		names->addSegment(_STR(t));
		names->setPosition(t);
	}

	(
	    "." t=< IDENTIFIER > {
			names->addSegment(_STR(t));
			names->setPosition(t);
	    }
	)*
	{
	}
	{
	    __ONERROR(names);
		return names;
	}

}

ClassDeclare* classDeclare() :
{
	ClassDeclare* clazz = nullptr;
	Token* cls = nullptr;
	Token* name = nullptr;
	ClassDeclareBlock* block = nullptr;
	
}
{
	cls="class" name=<IDENTIFIER> {
		 clazz = new ClassDeclare();
		 clazz->setName(_STR(name));
	}
	block=classDeclareBlock() {
	    clazz->setPositions(cls, block);
	    clazz->setBlock(block);
	}
	{
	    __ONERROR(clazz);
		return clazz;
	}
}

ClassDeclareBlock* classDeclareBlock() :
{
	ClassDeclareBlock* block = nullptr;
	Token* begin, *end;
	
	MethodDeclare* method = nullptr;
	MemberVariableDeclare* member = nullptr;

	AccessControlDeclare* ctrl = nullptr;
	bool _static=false;
	AbstractType* type = nullptr;
	Token* t=nullptr;
}
{
	begin="{" {
		block = new ClassDeclareBlock();
		block->setPosition(begin);
	}

	(
		ctrl=accessControlDeclare() {
	    }

		[
			t="static" {
			    _static=true;
			}
		]

		type=typeDeclare() {
		}
	
		t=< IDENTIFIER > {
		}

		(			method=methodDeclare(ctrl, _static, type, t) {
				block->addMethod(method);
			}
			|
			member=memberVariableDeclare(ctrl, _static, type, t) {
				block->addVariable(member);
			}
		)
		{
		    _static = false;
		}
	)*

	
	 end="}"
	{
   		block->setPosition(end);
	}
	{
		__ONERROR(block);
		return block;
	}
}

MethodDeclare* methodDeclare(AccessControlDeclare* ctrl, bool _static, AbstractType* type, Token* identifier) : {
    MethodDeclare* method = new MethodDeclare();

    method->setPosition(ctrl);
    
	method->setAccessControl(ctrl);
	method->setStatic(_static);
	method->setType(type);
	method->setName(_STR(identifier));
    
	Token* t = nullptr;
	ArgumentsListDeclare* args = nullptr;
	StatementBlock* block = nullptr;
}
{
	args=argumentsListDeclare() {
	  	method->setArguments(args);
		method->setPosition(args);
	}
	
	(
		block=statementBlock() {
			method->setBlock(block);
			method->setPosition(block);
		}
		|
		t=";" {
			method->setPosition(t);
		}
	)
	{
	}
	{
	    __ONERROR(method);
		return method;
	}
}

MemberVariableDeclare* memberVariableDeclare(AccessControlDeclare* ctrl, bool _static, AbstractType* type, Token* identifier) : {
    MemberVariableDeclare* variable = new MemberVariableDeclare();
	Token* t = nullptr;
	
	variable->setPosition(ctrl);

	variable->setAccessControl(ctrl);
	variable->setStatic(_static);
	variable->setType(type);
	variable->setName(_STR(identifier));
}
{
	t=";" {
		variable->setPosition(t);
	}
	
	{
	    __ONERROR(variable);
		return variable;
	}
}

AccessControlDeclare* accessControlDeclare() : {
	Token* t = nullptr;
	AccessControlDeclare* ctrl = new AccessControlDeclare();
}
{
    ( 
		t="public" {
			ctrl->setCtrl(AccessControlDeclare::PUBLIC);
			ctrl->setPositions(_P(t, t));
		}
		|
		t="protected" {
			ctrl->setCtrl(AccessControlDeclare::PROTECTED);
			ctrl->setPositions(_P(t, t));
		}
		|      
		t="private" {
			ctrl->setCtrl(AccessControlDeclare::PRIVATE);
			ctrl->setPositions(_P(t, t));
		}
	)
	{
	    __ONERROR(ctrl);
		return ctrl;
	}
}

ArgumentsListDeclare* argumentsListDeclare() : {
    ArgumentsListDeclare* arguments = new ArgumentsListDeclare();
	Token* t = nullptr;
	ArgumentDeclare* arg = nullptr;
}
{
	t="(" {
		arguments->setPosition(t);
	}

	[
		arg=argumentDeclare() {
		    arguments->addArgument(arg);
		    arguments->setPosition(arg);
		}
		(
		    "," arg=argumentDeclare() {
		        arguments->addArgument(arg);
		        arguments->setPosition(arg);
		    }		)*
	]

	t=")" {
		arguments->setPosition(t);
	}
	{
	    __ONERROR(arguments);
		return arguments;
	}
}


ArgumentDeclare* argumentDeclare() : {
	ArgumentDeclare* arg = new ArgumentDeclare();
	AbstractType* type = nullptr;
	Token* t = nullptr;
}
{
    type=typeDeclare() {
		arg->setType(type);
		arg->setPosition(type);
    }

    t=< IDENTIFIER > {
		arg->setName(_STR(t));
		arg->setPosition(t);
    }

	{
	    __ONERROR(arg);
		return arg;
	}
}




AbstractType* typeDeclare() : {
	AbstractType* dec = nullptr;
}
{
	(		dec=charType()
		|
		dec=shortType()
		|
		dec=intType()
		|
		dec=longType()
		|
		dec=stringType()
		|
		dec=voidType()
	)
	{
	}
	{
		__ONERROR(dec);
		return dec;
	}
}

CharType* charType() : {
	CharType* dec = new CharType();
	Token* t=nullptr;
}
{
	t="char" {
		dec->setPositions(_P(t, t));
	}
	{
		__ONERROR(dec);
		return dec;
	}
}

ShortType* shortType() : {
	ShortType* dec = new ShortType();
	Token* t=nullptr;
}
{
	t="short" {
		dec->setPositions(_P(t, t));
	}
	{
		__ONERROR(dec);
		return dec;
	}
}

IntType* intType() : {
	IntType* dec = new IntType();
	Token* t=nullptr;
}
{
	t="int" {
		dec->setPositions(_P(t, t));
	}
	{
		__ONERROR(dec);
		return dec;
	}
}

LongType* longType() : {
	LongType* dec = new LongType();
	Token* t=nullptr;
}
{
	t="long" {
		dec->setPositions(_P(t, t));
	}
	{
		__ONERROR(dec);
		return dec;
	}
}

StringType* stringType() : {
	StringType* dec = new StringType();
	Token* t=nullptr;
}
{
	t="String" {
		dec->setPositions(_P(t, t));
	}
	{
		__ONERROR(dec);
		return dec;
	}
}

VoidType* voidType() : {
	VoidType* dec = new VoidType();
	Token* t=nullptr;
}
{
	t="void" {
		dec->setPositions(_P(t, t));
	}
	{
		__ONERROR(dec);
		return dec;
	}
}


/******************************************************************************************
* Alinous Language Statements Starts
*/

StatementBlock* statementBlock() : {
	StatementBlock* block = new StatementBlock();
	Token* t = nullptr;
}
{
	t="{" {
		block->setPosition(t);
	}
	
	
	t="}" {
		block->setPosition(t);
	}
	{
	    __ONERROR(block);
		return block;
	}
}
