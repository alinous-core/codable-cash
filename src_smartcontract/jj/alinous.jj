options {
JAVA_UNICODE_ESCAPE = true;
UNICODE_INPUT = true;
OUTPUT_LANGUAGE = "c++";
NAMESPACE = "alinouslang";
OUTPUT_DIRECTORY = "src_gen/alinous_lang/";
FORCE_LA_CHECK = false;
ERROR_REPORTING = true;
PARSER_INCLUDES = "sc/alinouslang.h";
//STATIC = false; // ignored by c++
}

PARSER_BEGIN(AlinousLang)

// write includes here

PARSER_END(AlinousLang)

/******************************************************************************************
* Alinous Language Lex
*/

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

<*>TOKEN :
{
	<#NOTASCII: ["\u0080"-"\ufaff"]>	|
	<#ASCILETTER: ["a"-"z"] | ["A"-"Z"] | ["_"]> |
	<#NUMBERLETTER: ["0"-"9"]> |

	
	<#CHARACTOR: <NOTASCII> | <ASCILETTER> | <NUMBERLETTER> >
}

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        <DECIMAL_FLOATING_POINT_LITERAL>
      | <HEXADECIMAL_FLOATING_POINT_LITERAL>
  >
|
  < #DECIMAL_FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]
  >
|
  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < #HEXADECIMAL_FLOATING_POINT_LITERAL:
        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
  >
|
  < #HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+ >

|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | "u" (["0"-"9","a"-"f","A"-"F"])+
            )
          )
      )
      "'"
  >
|
  < SQL_STRING_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            | "u" (["0"-"9","a"-"f","A"-"F"])+
            )
          )
      )*
      "'"
  >
}

TOKEN :
{
	<SEMI_COLON: ";">		|
	<EQUALS: "=">			|
	<ASTERISK: "*">			|
	<PLUSPLUS: "++">		|
	<PLUS: "+">				|
	<MINUSMINUS: "--">		|
	<MINUS: "-">			|
	<DIV: "/">				|
	<MODULO: "%">			|
	<LOGICAL_AND: "&&">		|
	<LOGICAL_OR: "||">		|
	<BIT_AND: "&">			|
	<BIT_OR: "|">			|
	<L_PARENTHESIS: "(">	|
	<R_PARENTHESIS: ")">	|
	<L_BRACKET: "[">		|
	<R_BRACKET: "]">		|
	<DOLLAR: "$">			|
	<DOT: ".">				|
	<COMMA: ",">			|
	<AT_AT_MARK: "@@">		|
	<AT_MARK: "@">			|
	<L_BRACE: "{">			|
	<R_BRACE: "}">			|
	<CMP_EQUALS: "==">		|
	<CMP_NOTEQUALS: "!=">	|
	< GT: ">" >				|
	<GEQ: ">=">				|
	<LT: "<">				|
	<LEQ: "<=">				|
	<NOT: "!">				|
	<COLON: ":">			|

	<RSIGNEDSHIFT: ">>" >	|
	<RUNSIGNEDSHIFT: ">>>" >
}

TOKEN :
{
<IMPORT: "import">
| <PACKAGE: "package">
| <CLASS: "class">
| <CLASS_INTERFACE: "interface">
| < ABSTRACT: "abstract" >
| < BREAK: "break" >
| < CHAR: "char" >
| < SHORT: "short" >
| < INT: "int" >
| < LONG: "long" >
| < STRING: "String" >
| < CASE: "case" >
| < CATCH: "catch" >
| < _CONST: "const" >
| < CONTINUE: "continue" >
| < DO: "do" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FINALLY: "finally" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < INSTANCEOF: "instanceof" >
| < NEW: "new" >
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >

| < TRY: "try" >
| < VOID: "void" >
| < WHILE: "while" >
| <INCLUDE: "include" >
	
| < TRUE: "true" >
| < FALSE: "false" >
}


TOKEN [IGNORE_CASE] :
{
	<SELECT: "SELECT">	|
	<INSERT: "INSERT">	|
	<UPDATE: "UPDATE">	|
	<DELETE: "DELETE">	|
	<INTO: "INTO">		|
	<FROM: "FROM">		|
	<WHERE: "WHERE">	|
	<OR: "OR">			|
	<SQLAND: "AND">		|
	<LIKE: "LIKE">		|
	<ESCAPE: "<ESCAPE>">	|
	<LEFT: "LEFT">		|
	<RIGHT: "RIGHT">	|
	<NATURAL: "NATURAL">|
	<INNER: "INNER">	|
	<OUTER: "OUTER">	|
	<FULL: "FULL">		|
	<JOIN: "JOIN">		|
	<CROSS: "CROSS">	|
	<SET: "SET">		|
	<VALUES: "VALUES">	|
	<GROUP: "GROUP">	|
	<BY: "BY">			|
	<HAVING: "HAVING">	|
	<ORDER: "ORDER">	|
	<ASC: "ASC">		|
	<DESC: "DESC">		|
	
	<LIMIT: "LIMIT">	|
	<OFFSET: "OFFSET">	|
	<ON: "ON">			|
	<SQL_NOT: "NOT">	|
	<AS: "AS">			|
	<DISTINCT: "DISTINCT">		|
	
	<SHARE: "SHARE">	|
	<NOWAIT: "NOWAIT">	|
	<OF: "OF">			|
	
	<IN: "IN">			|
	<BETWEEN: "BETWEEN">	|
	<IS: "IS">			|
	
	<BEGIN: "BEGIN">	|
	<PREPARE: "PREPARE">	|
	<TRANSACTION: "TRANSACTION">	|
	<ISOLATION: "ISOLATION">	|
	<LEVEL: "LEVEL">	|
	
	<COMMIT: "COMMIT">	|
	<PREPARED: "PREPARED">	|
	<END: "END">		|
	<ROLLBACK: "ROLLBACK">		|

	<CREATE: "CREATE">		|
	<DROP: "DROP">		|
	<ALTER: "ALTER">	|
	<TABLE: "TABLE">	|
	<SQL_DEFAULT: "DEFAULT">	|
	<ADD: "ADD">	|
	<RENAME: "RENAME">	|
	<COLUMN: "COLUMN">	|
	<TO: "TO">	|
	<PRIMARY: "PRIMARY">	|
	<KEY: "KEY">	|
	<UNIQUE: "UNIQUE">	|
	<CHECK: "CHECK">	|
	<RETURNS: "RETURNS">	|
	<SETOF: "SETOF">	|
	<LANGUAGE: "LANGUAGE">	|
	<REPLACE: "REPLACE">	|
	<INDEX: "INDEX">	|
	<USING: "USING">	|
	
	<EACH: "EACH">		|
	<ROW: "ROW">		|
	<STATEMENT: "STATEMENT">|
	<EXECUTE: "EXECUTE">	|
	<PROCEDURE: "PROCEDURE">		|
	<EXISTS: "EXISTS">	|
	
	<TRIGGER: "TRIGGER">	|
	<BEFORE: "BEFORE">	|
	<AFTER: "AFTER">	|
	
	<FOREIGN: "FOREIGN">	|
	<REFERENCES: "REFERENCES">	|
	
	<ADJUST_WHERE: "ADJUST_WHERE">	|
	<ADJUST_SET: "ADJUST_SET">	|
	
	<BOOL: "BOOL">		|
	
	<_NULL: "NULL">		|
	
	<FUNCTION: "FUNCTION">	|

	<USE: "USE" >  |
	<REGION: "REGION"> |
	<PARTITION: "PARTITION" > |
	<SUB: "SUB">		|
	<SERIALIZABLE: "SERIALIZABLE">	|
	<READ: "READ">	|
	<COMMITTED: "COMMITTED">


}

TOKEN :
{
	<IDENTIFIER: <ASCILETTER> (<ASCILETTER> | <NUMBERLETTER>)*>
}

MORE:
{
	< "/*" > :COMM	 |
	< "//" > :L_COMM
}

<L_COMM>SPECIAL_TOKEN:
{
	< "\n" > : DEFAULT
}

<L_COMM>MORE:
{
	< ~[] >
}

<COMM>SPECIAL_TOKEN:
{
	< "*/" > : DEFAULT
}

<COMM>MORE:
{
	< ~[] >
}

/******************************************************************************************
* Alinous Language Starts
*/

CompilationUnit* compilationUnit() :
{
	CompilationUnit* unit = new CompilationUnit();
	PackageDeclare* pkg = nullptr;
	ClassDeclare* clazz = nullptr;
}
{
	[
		pkg=packageDeclare() {
			unit->setPackage(pkg);
		}
	]
    
	(
	    clazz=classDeclare() {
			unit->setPosition(clazz);
			unit->addClassDeclare(clazz);
	    }
	)+
	<EOF>
	{
		return unit;
	}
}

PackageDeclare* packageDeclare() : {
	PackageDeclare* pkg = nullptr;
	PackageNameDeclare* name = nullptr;
	Token* t = nullptr;
}
{
	t="package" {
		pkg=new PackageDeclare();
		pkg->setPosition(t);
	}

	name=packageNameDeclare() {
	    pkg->setName(name);
		pkg->setPosition(name);
	}
	
	t=";" {
		pkg->setPosition(t);
	}
	{
	    __ONERROR(pkg);
		return pkg;
	}
}

PackageNameDeclare* packageNameDeclare() :
{
	PackageNameDeclare* names = nullptr;
	Token* t = nullptr;
}
{
	t=< IDENTIFIER > {
	    names = new PackageNameDeclare();
		names->addSegment(_STR(t));
		names->setPosition(t);
	}

	(
	    "." t=< IDENTIFIER > {
			names->addSegment(_STR(t));
			names->setPosition(t);
	    }
	)*
	{
	}
	{
	    __ONERROR(names);
		return names;
	}

}

ClassDeclare* classDeclare() :
{
	ClassDeclare* clazz = nullptr;
	Token* cls = nullptr;
	Token* name = nullptr;
	ClassDeclareBlock* block = nullptr;
	
}
{
	cls="class" name=<IDENTIFIER> {
		 clazz = new ClassDeclare();
		 clazz->setName(_STR(name));
	}
	block=classDeclareBlock() {
	    clazz->setPositions(cls, block);
	    clazz->setBlock(block);
	}
	{
	    __ONERROR(clazz);
		return clazz;
	}
}

ClassDeclareBlock* classDeclareBlock() :
{
	ClassDeclareBlock* block = nullptr;
	Token* begin, *end;
	
	MethodDeclare* method = nullptr;
	MemberVariableDeclare* member = nullptr;

	AccessControlDeclare* ctrl = nullptr;
	bool _static=false;
	AbstractType* type = nullptr;
	Token* t=nullptr;
}
{
	begin="{" {
		block = new ClassDeclareBlock();
		block->setPosition(begin);
	}

	(
		ctrl=accessControlDeclare() {
	    }

		[
			t="static" {
			    _static=true;
			}
		]

		type=typeDeclare() {
		}
	
		t=< IDENTIFIER > {
		}

		(			method=methodDeclare(ctrl, _static, type, t) {
				block->addMethod(method);
			}
			|
			member=memberVariableDeclare(ctrl, _static, type, t) {
				block->addVariable(member);
			}
		)
		{
		    _static = false;
		}
	)*

	
	 end="}"
	{
   		block->setPosition(end);
	}
	{
		__ONERROR(block);
		return block;
	}
}

MethodDeclare* methodDeclare(AccessControlDeclare* ctrl, bool _static, AbstractType* type, Token* identifier) : {
    MethodDeclare* method = new MethodDeclare();

    method->setPosition(ctrl);
    
	method->setAccessControl(ctrl);
	method->setStatic(_static);
	method->setType(type);
	method->setName(_STR(identifier));
    
	Token* t = nullptr;
	ArgumentsListDeclare* args = nullptr;
	StatementBlock* block = nullptr;
}
{
	args=argumentsListDeclare() {
	  	method->setArguments(args);
		method->setPosition(args);
	}
	
	(
		block=statementBlock() {
			method->setBlock(block);
			method->setPosition(block);
		}
		|
		t=";" {
			method->setPosition(t);
		}
	)
	{
	}
	{
	    __ONERROR(method);
		return method;
	}
}

MemberVariableDeclare* memberVariableDeclare(AccessControlDeclare* ctrl, bool _static, AbstractType* type, Token* identifier) : {
    MemberVariableDeclare* variable = new MemberVariableDeclare();
	Token* t = nullptr;
	
	variable->setPosition(ctrl);

	variable->setAccessControl(ctrl);
	variable->setStatic(_static);
	variable->setType(type);
	variable->setName(_STR(identifier));
}
{
	t=";" {
		variable->setPosition(t);
	}
	
	{
	    __ONERROR(variable);
		return variable;
	}
}

AccessControlDeclare* accessControlDeclare() : {
	Token* t = nullptr;
	AccessControlDeclare* ctrl = new AccessControlDeclare();
}
{
    ( 
		t="public" {
			ctrl->setCtrl(AccessControlDeclare::PUBLIC);
			ctrl->setPositions(_P(t, t));
		}
		|
		t="protected" {
			ctrl->setCtrl(AccessControlDeclare::PROTECTED);
			ctrl->setPositions(_P(t, t));
		}
		|      
		t="private" {
			ctrl->setCtrl(AccessControlDeclare::PRIVATE);
			ctrl->setPositions(_P(t, t));
		}
	)
	{
	    __ONERROR(ctrl);
		return ctrl;
	}
}

ArgumentsListDeclare* argumentsListDeclare() : {
    ArgumentsListDeclare* arguments = new ArgumentsListDeclare();
	Token* t = nullptr;
	ArgumentDeclare* arg = nullptr;
}
{
	t="(" {
		arguments->setPosition(t);
	}

	[
		arg=argumentDeclare() {
		    arguments->addArgument(arg);
		    arguments->setPosition(arg);
		}
		(
		    "," arg=argumentDeclare() {
		        arguments->addArgument(arg);
		        arguments->setPosition(arg);
		    }		)*
	]

	t=")" {
		arguments->setPosition(t);
	}
	{
	    __ONERROR(arguments);
		return arguments;
	}
}


ArgumentDeclare* argumentDeclare() : {
	ArgumentDeclare* arg = new ArgumentDeclare();
	AbstractType* type = nullptr;
	Token* t = nullptr;
}
{
    type=typeDeclare() {
		arg->setType(type);
		arg->setPosition(type);
    }

    t=< IDENTIFIER > {
		arg->setName(_STR(t));
		arg->setPosition(t);
    }

	{
	    __ONERROR(arg);
		return arg;
	}
}




AbstractType* typeDeclare() : {
	AbstractType* dec = nullptr;
}
{
	(		dec=charType()
		|
		dec=shortType()
		|
		dec=intType()
		|
		dec=longType()
		|
		dec=stringType()
		|
		dec=voidType()
	)
	{
	}
	{
		__ONERROR(dec);
		return dec;
	}
}

CharType* charType() : {
	CharType* dec = new CharType();
	Token* t=nullptr;
}
{
	t="char" {
		dec->setPositions(_P(t, t));
	}
	{
		__ONERROR(dec);
		return dec;
	}
}

ShortType* shortType() : {
	ShortType* dec = new ShortType();
	Token* t=nullptr;
}
{
	t="short" {
		dec->setPositions(_P(t, t));
	}
	{
		__ONERROR(dec);
		return dec;
	}
}

IntType* intType() : {
	IntType* dec = new IntType();
	Token* t=nullptr;
}
{
	t="int" {
		dec->setPositions(_P(t, t));
	}
	{
		__ONERROR(dec);
		return dec;
	}
}

LongType* longType() : {
	LongType* dec = new LongType();
	Token* t=nullptr;
}
{
	t="long" {
		dec->setPositions(_P(t, t));
	}
	{
		__ONERROR(dec);
		return dec;
	}
}

StringType* stringType() : {
	StringType* dec = new StringType();
	Token* t=nullptr;
}
{
	t="String" {
		dec->setPositions(_P(t, t));
	}
	{
		__ONERROR(dec);
		return dec;
	}
}

VoidType* voidType() : {
	VoidType* dec = new VoidType();
	Token* t=nullptr;
}
{
	t="void" {
		dec->setPositions(_P(t, t));
	}
	{
		__ONERROR(dec);
		return dec;
	}
}


/******************************************************************************************
* Alinous Language Statements Starts
*/

AbstractStatement* statement() : {
	AbstractStatement* stmt = nullptr;
}
{
	(
		stmt=statementBlock() |
		stmt=expressionStatement() |
		stmt=ctrlStatement()
	)
	{}
	{
		return stmt;
	}
}

StatementBlock* statementBlock() : {
	StatementBlock* block = new StatementBlock();
	AbstractStatement* stmt = nullptr;
	Token* t = nullptr;
}
{
	t="{" {
		block->setPosition(t);
	}
	
	(
		stmt=statement() {
			block->addStatement(stmt);
			block->setPosition(stmt);
		}
	)*
	
	t="}" {
		block->setPosition(t);
	}
	{
	    __ONERROR(block);
		return block;
	}
}


ExpressionStatement* expressionStatement() : {
	ExpressionStatement* stmt = new ExpressionStatement();
	Token* t = nullptr;
	AbstractExpression* exp = nullptr;
}
{
	exp=expression() {
		stmt->setExpression(exp);
		stmt->setPosition(exp);
	}
	t=";" {
		stmt->setPosition(t);
	}
	{
		__ONERROR(stmt);
		return stmt;
	}
}



/******************************************************************************************
* Alinous Language Control Statements Starts
*/

AbstractStatement* ctrlStatement() : {
	AbstractStatement* stmt = nullptr;
}
{
	(
		stmt=ifStatement() |
		stmt=breakStatement()
	)
	{}
	{
		return stmt;
	}
}

BreakStatement* breakStatement() : {
	BreakStatement* stmt = new BreakStatement();
	Token* t = nullptr;
}
{
	t="break" {
		stmt->setPosition(t);
	}
	t=";" {
		stmt->setPosition(t);
	}
	{
		 __ONERROR(stmt);
		return stmt;
	}	
}

IfStatement* ifStatement() : {
	IfStatement* ifstmt = new IfStatement();
	AbstractExpression* exp;
	AbstractStatement* stmt;
	Token* t = nullptr;
}
{
	t="if" {
		ifstmt->setPosition(t);
	}
	"("
	exp=expression() {
		ifstmt->setExpression(exp);
		ifstmt->setPosition(exp);
	}
	
	")"
	
	stmt=statement() {
		ifstmt->setStatement(stmt);
		ifstmt->setPosition(stmt);
	}
	{
		 __ONERROR(ifstmt);
		return ifstmt;
	}
}



/******************************************************************************************
* Alinous Language Expressions Starts
*/

AbstractExpression* expression() : {
	AbstractExpression* exp = nullptr;
}
{
	(
		exp=conditionalOrExpression()
	)
	{
	}
	{
		return exp;
	}
}

AbstractExpression* conditionalOrExpression() : {
	Token* t = nullptr;
	ConditionalOrExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	left=conditionalAndExpression()
	(

		t="||" {
			if(exp == nullptr){
				exp = new ConditionalOrExpression();
				exp->setPosition(left);
				exp->addExp(left);
				left = exp;
			}
			
			exp->setPosition(t);
		}

		right=conditionalAndExpression() {
			exp->addExp(right);
			exp->setPosition(right);
		}	
	)*
	{}
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* conditionalAndExpression() : {
	Token* t = nullptr;
	ConditionalAndExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	left=orExpression()
	(

		t="&&" {
			if(exp == nullptr){
				exp = new ConditionalAndExpression();
				exp->setPosition(left);
				exp->addExp(left);
				left = exp;
			}
			
			exp->setPosition(t);
		}

		right=orExpression() {
			exp->addExp(right);
			exp->setPosition(right);
		}	
	)*
	{}
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* orExpression() : {
	Token* t = nullptr;
	OrExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	left=exclusiveOrExpression()
	(

		t="|" {
			if(exp == nullptr){
				exp = new OrExpression();
				exp->setPosition(left);
				exp->addExp(left);
				left = exp;
			}
			
			exp->setPosition(t);
		}

		right=exclusiveOrExpression() {
			exp->addExp(right);
			exp->setPosition(right);
		}	
	)*
	{}
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* exclusiveOrExpression() : {
	Token* t = nullptr;
	ExclusiveOrExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	left=andExpression()
	(

		t="^" {
			if(exp == nullptr){
				exp = new ExclusiveOrExpression();
				exp->setPosition(left);
				exp->addExp(left);
				left = exp;
			}
			
			exp->setPosition(t);
		}

		right=andExpression() {
			exp->addExp(right);
			exp->setPosition(right);
		}	
	)*
	{}
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* andExpression() : {
	Token* t = nullptr;
	AndExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	left=equalityExpression()
	(

		t="&" {
			if(exp == nullptr){
				exp = new AndExpression();
				exp->setPosition(left);
				exp->addExp(left);
				left = exp;
			}
			
			exp->setPosition(t);
		}

		right=equalityExpression() {
			exp->addExp(right);
			exp->setPosition(right);
		}	
	)*
	{}
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* equalityExpression() : {
	Token* t = nullptr;
	EqualityExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	left=relationalExpression()
	[
		(
			t="==" {
				exp = new EqualityExpression();
				exp->setPosition(left);
				exp->setLeft(left);
				left = exp;

				exp->setPosition(t);
				exp->setOp(EqualityExpression::EQ);
			}
			|
			t="!=" {
				exp = new EqualityExpression();
				exp->setPosition(left);
				exp->setLeft(left);
				left = exp;

				exp->setPosition(t);
				exp->setOp(EqualityExpression::NOT_EQ);
			}
		)
		
		right=relationalExpression() {
			exp->setRight(right);
			exp->setPosition(right);
		}
	]
	{}
	{
		__ONERROR(left);
		return left;
	}
}


AbstractExpression* relationalExpression() : {
	Token* t = nullptr;
	RelationalExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	left=shiftExpression()
	
	[
		(
			t=">" {
				exp = new RelationalExpression();
				exp->setPosition(left);
				exp->setLeft(left);
				left = exp;

				
				exp->setPosition(t);
				exp->setOp(RelationalExpression::GT);
			}
			|
			t=">=" {
				exp = new RelationalExpression();
				exp->setPosition(left);
				exp->setLeft(left);
				left = exp;
				
				exp->setPosition(t);
				exp->setOp(RelationalExpression::GT_EQ);
			}
			|
			t="<" {
				exp = new RelationalExpression();
				exp->setPosition(left);
				exp->setLeft(left);
				left = exp;

				
				exp->setPosition(t);
				exp->setOp(RelationalExpression::LT);
			}
			|
			t="<=" {
				exp = new RelationalExpression();
				exp->setPosition(left);
				exp->setLeft(left);
				left = exp;
				
				exp->setPosition(t);
				exp->setOp(RelationalExpression::LT_EQ);
			}
		)
		
		right=shiftExpression() {
			exp->setRight(right);
			exp->setPosition(right);
		}
	]
	{}
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* shiftExpression() : {
	Token* t = nullptr;
	ShiftExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	left=additiveExpression()
	(
		(
			t="<<" {
				if(exp == nullptr){
					exp = new ShiftExpression();
					exp->setPosition(left);
					exp->addExp(left);
					left = exp;
				}
				
				exp->setPosition(t);
				exp->addOpe(ShiftExpression::LEFT);
			}
			|
			t=">>" {
				if(exp == nullptr){
					exp = new ShiftExpression();
					exp->setPosition(left);
					exp->addExp(left);
					left = exp;
				}
				
				exp->setPosition(t);
				exp->addOpe(ShiftExpression::RIGHT);
			}
		)

		right=additiveExpression() {
			exp->addExp(right);
			exp->setPosition(right);
		}	
	)*
	{}
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* additiveExpression() : {
	Token* t = nullptr;
	AddExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	left=multiplicativeExpression()
	(
		(
			t="+" {
				if(exp == nullptr){
					exp = new AddExpression();
					exp->setPosition(left);
					exp->addExp(left);
					left = exp;
				}
				
				exp->setPosition(t);
				exp->addOpe(AddExpression::ADD);
			}
			|
			t="-" {
				if(exp == nullptr){
					exp = new AddExpression();
					exp->setPosition(left);
					exp->addExp(left);
					left = exp;
				}
				
				exp->setPosition(t);
				exp->addOpe(AddExpression::SUB);
			}
		)

		right=multiplicativeExpression() {
			exp->addExp(right);
			exp->setPosition(right);
		}	
	)*
	{}
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* multiplicativeExpression() : {
	Token* t = nullptr;
	MultiplicativeExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	left=negateExpression()
	(
		(
			t="*" {
				if(exp == nullptr){
					exp = new MultiplicativeExpression();
					exp->setPosition(left);
					exp->addExp(left);
					left = exp;
				}
				exp->addOpe(MultiplicativeExpression::MUL);
				exp->setPosition(t);
			}
			|
			t="/" {
				if(exp == nullptr){
					exp = new MultiplicativeExpression();
					exp->setPosition(left);
					exp->addExp(left);
					left = exp;
				}
				exp->addOpe(MultiplicativeExpression::DIV);
				exp->setPosition(t);
			}
			|
			t="%" {
				if(exp == nullptr){
					exp = new MultiplicativeExpression();
					exp->setPosition(left);
					exp->addExp(left);
					left = exp;
				}
				exp->addOpe(MultiplicativeExpression::MOD);
				exp->setPosition(t);
			}
		)
		
		right=negateExpression() {
			exp->addExp(right);
			exp->setPosition(right);
		}
	)*
	{}
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* negateExpression() :{
	Token* t = nullptr;
	NegateExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	[
		t="-" {
			exp = new NegateExpression();
			exp->setPosition(t);
			left = exp;
		}
	]
	right=postIncrementExpression() {
		if(left==nullptr){
			left = right;
		}
		else{
			exp->setExpression(right);
			exp->setPosition(right);
		}
	}
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* postIncrementExpression() : {
	Token* t = nullptr;
	PostIncrementExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
}
{
	left=preIncrementExpression()
	
	[
		(
			t="--" {
				exp = new PostIncrementExpression();
				exp->setExpression(left);
				exp->setOpe(PostIncrementExpression::MINUS);
				exp->setPosition(left);
				exp->setPosition(t);
				left = exp;
			}
			|
			t="++" {
				exp = new PostIncrementExpression();
				exp->setExpression(left);
				exp->setOpe(PostIncrementExpression::PLUS);
				exp->setPosition(left);
				exp->setPosition(t);
				left = exp;
			}			
		)
	]
	{}
	{
		__ONERROR(left);
		return left;
	}
	
}

AbstractExpression* preIncrementExpression() : {
	Token* t = nullptr;
	PreIncrementExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	[
		(
			t="--" {
				exp = new PreIncrementExpression();
				exp->setOpe(PreIncrementExpression::MINUS);
				exp->setPosition(t);
				left = exp;
			}
			|
			t="++" {
				exp = new PreIncrementExpression();
				exp->setOpe(PreIncrementExpression::PLUS);
				exp->setPosition(t);
				left = exp;
			}			
		)
	]
	right=bitReverseExpression() {
		if(left==nullptr){
			left = right;
		}
		else{
			exp->setExpression(right);
			exp->setPosition(right);
		}
	}
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* bitReverseExpression() : {
	Token* t = nullptr;
	BitReverseExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	[
		t="~" {
			exp = new BitReverseExpression();
			exp->setPosition(t);
			left = exp;
		}
	]
	right=notExpression() {
		if(left==nullptr){
			left = right;
		}
		else{
			exp->setExpression(right);
			exp->setPosition(right);
		}
	}
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* notExpression() : {
	Token* t = nullptr;
	NotExpression* exp = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	[
		t="!" {
			exp = new NotExpression();
			exp->setPosition(t);
			left = exp;
		}
	]
	right=castExpression() {
		if(left==nullptr){
			left = right;
		}
		else{
			exp->setExpression(right);
			exp->setPosition(right);
		}
	}
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* castExpression() : {
	Token* t = nullptr;
	CastExpression* exp = nullptr;
	AbstractType* type = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	[LOOKAHEAD(2)
		t="(" {
			exp = new CastExpression();
			exp->setPosition(t);
			left = exp;
		}
		
		type=typeDeclare() {
			exp->setType(type);
			exp->setPosition(type);
		}
		
		t=")" {
			exp->setPosition(t);
		}
	]
	
	right=memberReferenceExpression() {
		if(left==nullptr){
			left = right;
		}
		else{
			exp->setExpression(right);
			exp->setPosition(right);
		}
	}
	
	{
		__ONERROR(left);
		return left;
	}
}

AbstractExpression* memberReferenceExpression() :{
	MemberReferenceExpression* exp = nullptr;
	Token* t = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	left=arrayReferenceExpression() 
	(
		"." right=arrayReferenceExpression() {
			if(exp == nullptr){
				exp = new MemberReferenceExpression();
				exp->addExp(left);
				exp->setPosition(left);
				left = exp;
			}
			
			exp->addExp(right);
			exp->setPosition(right);
		}
	)*
	{
	}
	{
		__ONERROR(left);
		return left;
	}
	
}

AbstractExpression* arrayReferenceExpression() : {
	ArrayReferenceExpression* exp = nullptr;
	Token* t = nullptr;
	AbstractExpression* left = nullptr;
	AbstractExpression* right = nullptr;
}
{
	left=functionCallExpression() 
	(
		t="[" {
			if(exp == nullptr){
				exp = new ArrayReferenceExpression();
				exp->setExp(left);
				exp->setPosition(left);
				left = exp;
			}
		}
		right=expression()
		t="]" {
			exp->addIndex(right);
			exp->setPosition(t);
		}
	)*
	{}
	{
		__ONERROR(left);
		return left;
	}
}

// func call
AbstractExpression* functionCallExpression() : {
	FunctionCallExpression* exp = nullptr;
	Token* t = nullptr;
	AbstractExpression* left = nullptr;
}
{
	left=primitive()
	
	[LOOKAHEAD(2)
		t="(" {
			exp = new FunctionCallExpression();
			exp->setName(left);
			exp->setPosition(left);
			exp->setPosition(t);
			
			left = exp;
		}
		
		functionCallExpressionArg(exp)		
		
		t=")" {
			exp->setPosition(t);
		}
	]
	{}
	{
		__ONERROR(left);
		return left;
	}
}

void functionCallExpressionArg(FunctionCallExpression* exp) : {
	AbstractExpression* arg = nullptr;
	Token* t = nullptr;
}
{
	[
		arg=expression() {
			exp->addArgument(arg);
			exp->setPosition(arg);
		}
		
		(
			t="," {
				exp->setPosition(t);
			}
			
			arg=expression() {
				exp->addArgument(arg);
				exp->setPosition(arg);
			}
		)*
	]
}

AbstractExpression* primitive() : {
	AbstractExpression* exp = nullptr;
}
{
	(
		exp=parenthesisExpression() |
		exp=allocationExpression() |
		exp=literal() |
		exp=variableIdentifier()
	)
	{
	}
	{
		return exp;
	}
}

AllocationExpression* allocationExpression() : {
	AllocationExpression* exp = nullptr;
	PackageNameDeclare* packageName = nullptr;
	AbstractExpression* func = nullptr;
	Token* t = nullptr;
}
{
	t="new" {
		exp = new AllocationExpression();
		exp->setPosition(t);
	}
	[LOOKAHEAD(2)
		packageName=packageNameDeclare() {
			exp->setPackage(packageName);
			exp->setPosition(packageName);
		}
	]
	
	func=functionCallExpression() {
		exp->setExpression((FunctionCallExpression*)func);
		exp->setPosition(func);
	}	
	{
		 __ONERROR(exp);
		return exp;
	}
}

ParenthesisExpression* parenthesisExpression() : {
	ParenthesisExpression* exp = new ParenthesisExpression();
	AbstractExpression* e = nullptr;
	Token* t = nullptr;
}
{
	t="(" {
		exp->setPosition(t);
	}
	
	e=expression() {
		exp->setExp(e);
		exp->setPosition(e);
	}
	
	t=")" {
		exp->setPosition(t);
	}
	{
		 __ONERROR(exp);
		return exp;
	}
}


VariableIdentifier* variableIdentifier() : {
	VariableIdentifier* valId = new VariableIdentifier();
	Token* t = nullptr;
}
{
	t=<IDENTIFIER> {
		valId->setName(_STR(t));
	}
	{
		 __ONERROR(valId);
		return valId;
	}
}

AbstractExpression* literal() : {
	AbstractExpression* lit = nullptr;
}
{
	(
		lit=nullLiteral() |
		lit=booleanLiteral() |
		lit=numberLiteral() |
		lit=literalExpression()
	)
	{
	}
	{
		return lit;
	}
}


NullLiteral* nullLiteral() :
{
	NullLiteral* lit = new NullLiteral();
	Token* t = nullptr;
}
{
	t=<_NULL> {
		lit->setPositions(t, t);
	}
	{
		 __ONERROR(lit);
		return lit;
	}
}

NumberLiteral* numberLiteral() : {
	NumberLiteral* lit = new NumberLiteral();
	Token* t = nullptr;
}
{
	t=<INTEGER_LITERAL>
	{
		lit->setValue(_STR(t));
		lit->setPositions(t, t);
	}
	{
		 __ONERROR(lit);
		return lit;
	}
}


BooleanLiteral* booleanLiteral() : {
	BooleanLiteral* lit = new BooleanLiteral();
	Token* t = nullptr;
}
{
	(
		t="true" {
			lit->setValue(true);
		}
		|
		t="false" {
			lit->setValue(false);
		}
	)
	{
		lit->setPositions(t, t);
	}
	{
		 __ONERROR(lit);
		return lit;
	}
}

LiteralExpression* literalExpression() :
{
	LiteralExpression* lit = new LiteralExpression();
	Token* t = nullptr;
}
{
	(
		t=<STRING_LITERAL> {
			lit->setString(_STR(t), true);
		}
		|
		t=<SQL_STRING_LITERAL> {
			lit->setString(_STR(t), false);
		}
	){
		lit->setPositions(t, t);
	}
	{
		 __ONERROR(lit);
		return lit;
	}
}


